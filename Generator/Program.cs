using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace Generator {
	internal class Program {
		private static void Main(string[] args) {
			Download();

			Registry registry;
			using (var file = new FileStream("xml/gl.xml", FileMode.Open)) {
				var serializer = new XmlSerializer(typeof(Registry));
				registry = (Registry)serializer.Deserialize(file);
			}

			Process(registry, "gl", 1.0, 3.0); // 4.6
			//Process(registry, "gles1", 1.0);
		}

		private static void Process(Registry registry, string api, double min, double max) {
			var strings = new Dictionary<string, string> {
				{ "name", "ogl" },
				{ "NAME", "OGL" },
				{ "GENERATOR", $"OpenGL loader generated by Matthew A's tool at {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffffffZ}" },
				{ "LICENSE", registry.Comment },
				{ "TYPES", "" },
				{ "HEADER_BODY", "" },
				{ "SOURCE_PFN", "" },
				{ "LOADPROCS", "" }
			};

			foreach (var type in registry.Types.SelectMany(types => types.Types)) {
				if (type.Text.Count == 1) {
					// Struct declarations.
					strings["TYPES"] += $"{type.Name}{type.Text[0]}\n";
				} else if (type.Text.Count == 2) {
					// Typedef types.
					strings["TYPES"] += $"{type.Text[0]}{type.Name}{type.Text[1]}\n";
				} else if (type.Text.Count == 3) {
					// Typedef functions.
					strings["TYPES"] += $"{type.Text[0]}{(type.ApiEntry != null ? "GL_APIENTRY" : "")}{type.Text[1]}{type.Name}{type.Text[2]}\n";
				} else {
					throw new ArgumentException();
				}
			}

			foreach (var feature in registry.Features.Where(f => f.Api == api && f.Number >= min && f.Number <= max)) {
				//string section = $"#ifndef {feature.Name}\n#define {feature.Name} 1";
				string headerDefs = $"#ifndef {feature.Name}\n#define {feature.Name} 1\n/* SECTION: GL enumerant (token) definitions. */\n";
				string sourcePFN = $"#ifdef {feature.Name}\n";
				string loadProcs = $"#ifdef {feature.Name}\n";
				foreach (var enumName in feature.Requires.SelectMany(requires => requires.EnumNames)) {
					var @enum = registry.Find(enumName);
					headerDefs += $"#define {@enum.Name} {@enum.Value}\n";
				}

				headerDefs += "\n/* SECTION: GL command definitions. */\n";
				foreach (var commandName in feature.Requires.SelectMany(requires => requires.CommandNames)) {
					var command = registry.Find(commandName);
					var returnType = GlType(command.Prototype).TrimEnd();
					var procName = $"PFN{command.Prototype.Name.ToUpper()}PROC";
					var paramsString = string.Join(", ", command.Params.Select(param =>
						$"{GlType(param)} {param.Name}")
					);
					headerDefs += $"typedef {returnType}(GL_APIENTRYP {procName})({paramsString});\n";
					headerDefs += $"GL_APICALL {procName} {command.Prototype.Name};\n";

					sourcePFN += $"{procName} {command.Prototype.Name} = nullptr;\n";

					loadProcs += $"\t{command.Prototype.Name} = reinterpret_cast<{procName}>(proc(\"{command.Prototype.Name}\"));\n";
				}

				headerDefs += $"#endif /* {feature.Name} */\n";
				sourcePFN += $"#endif /* {feature.Name} */\n";
				loadProcs += $"#endif /* {feature.Name} */\n";
				strings["HEADER_BODY"] += headerDefs;
				strings["SOURCE_PFN"] += sourcePFN;
				strings["LOADPROCS"] += loadProcs;
			}

			Directory.CreateDirectory("include/GL");
			Directory.CreateDirectory("src");
			Output("../../../source.h.template", "include/GL/OpenGL.h", strings);
			Output("../../../source.cpp.template", "src/OpenGL.cpp", strings);
		}

		private static void Output(string inPath, string outPath, IReadOnlyDictionary<string, string> strings) {
			using var input = new StreamReader(inPath);
			using var output = new StreamWriter(outPath);
			
			string line;
			while ((line = input.ReadLine()) != null) {
				var matches = Regex.Matches(line, @"%%(.*?)%%");
				if (matches.Count != 0) {
					for (int i = 0; i < matches.Count; i++) {
						string key = matches[i].Value;
						key = key.Substring(2, key.Length - 4);
						if (strings.ContainsKey(key)) {
							line = line.Replace(matches[i].Value, strings[key]);
						}
					}
				}

				output.WriteLine(line);
			}
		}

		private static string GlType(RegistryCommands.Command.Proto proto) {
			return !string.IsNullOrEmpty(proto.PointerType) ? proto.PointerType : proto.Text[0];
		}

		private static string GlType(RegistryCommands.Command.Param param) {
			return !string.IsNullOrEmpty(param.PointerType) ? param.PointerType : param.Text[0];
		}

		private static void Download() {
			using var client = new WebClient();

			Directory.CreateDirectory("xml");
			if (!File.Exists("xml/egl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/EGL-Registry/master/api/egl.xml", "xml/egl.xml");
			if (!File.Exists("xml/gl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/gl.xml", "xml/gl.xml");
			if (!File.Exists("xml/glx.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/glx.xml", "xml/glx.xml");
			if (!File.Exists("xml/wgl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/wgl.xml", "xml/wgl.xml");
				
			Directory.CreateDirectory("include/KHR");
			if (!File.Exists("include/KHR/khrplatform.h"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/EGL-Registry/master/api/KHR/khrplatform.h", "include/KHR/khrplatform.h");
		}
	}

}
