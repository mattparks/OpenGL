using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Xml.Serialization;

namespace Generator {
	internal class Program {
		private static void Main(string[] args) {
			Download();

			Registry registry;
			using (var file = new StreamReader("xml/gl.xml")) {
				var serializer = new XmlSerializer(typeof(Registry));
				registry = (Registry)serializer.Deserialize(file);
			}

			Process(registry, "OpenGL", "gl", 1.0, 3.0); // 4.6
			//Process(registry, "GLES1", "gles1", 1.0, 1.0);
		}

		private static void Process(Registry registry, string outName, string api, double min, double max) {
			var strings = new Dictionary<string, string> {
				{ "GENERATOR", $"{outName} loader generated by Matthew A's tool at {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffffffZ}" },
				{ "LICENSE", registry.Comment },
				{ "NAMESPACE", api },
				{ "HEADER_FILE", $"{api.ToUpper()}/{outName}.h" },
				{ "SOURCE_FILE", $"{outName}.cpp" }
			};

			string typeDefs = "";
			foreach (var type in registry.Types.SelectMany(types => types.Types)) {
				if (type.Text.Count == 1) {
					// Struct declarations.
					typeDefs += $"{type.Name}{type.Text[0]}\n";
				} else if (type.Text.Count == 2) {
					// Typedef types.
					typeDefs += $"{type.Text[0]}{type.Name}{type.Text[1]}\n";
				} else if (type.Text.Count == 3) {
					// Typedef functions.
					var apiEntry = type.ApiEntry != null ? "GL_APIENTRY" : "";
					typeDefs += $"{type.Text[0]}{apiEntry}{type.Text[1]}{type.Name}{type.Text[2]}\n";
				} else {
					throw new ArgumentException();
				}
			}
			strings.Add("GL_TYPEDEFS", typeDefs);

			string commandsAndEnums = "";
			string commandsPFN = "";
			foreach (var feature in registry.Features.Where(f => f.Api == api && f.Number >= min && f.Number <= max)) {
				commandsAndEnums += $"#ifndef {feature.Name}\n#define {feature.Name} 1\n/* SECTION: GL enumerant (token) definitions. */\n";
				commandsPFN += $"#ifdef {feature.Name}\n";

				foreach (var enumName in feature.Requires.SelectMany(requires => requires.EnumNames)) {
					var @enum = registry.Find(enumName);
					commandsAndEnums += $"constexpr GLenum {@enum.Name} = {@enum.Value};\n";
				}

				commandsAndEnums += "\n/* SECTION: GL command definitions. */\n";
				foreach (var commandName in feature.Requires.SelectMany(requires => requires.CommandNames)) {
					var command = registry.Find(commandName);
					var name = command.Prototype.Name;
					//var shortName = name.StartsWith("gl") ? name.Substring(2) : name;
					var returnType = GlType(command.Prototype);
					var paramsString = string.Join(", ", command.Params.Select(param =>
						$"{GlType(param)} {param.Name}")
					);
					commandsAndEnums += $"{returnType} {name}({paramsString});\n";

					var paramTypes = string.Join(", ", command.Params.Select(GlType));
					var paramNames = string.Join(", ", command.Params.Select(param => param.Name));
					commandsPFN += $"{returnType} {name}({paramsString}) {{\n";
					commandsPFN += $"\tstatic const auto {name}_ = reinterpret_cast<{returnType}(WINAPI *)({paramTypes})>(getProcAddress(\"{name}\"));\n";
					commandsPFN += $"\treturn {name}_({paramNames});\n}}\n";
				}

				commandsAndEnums += $"#endif /* {feature.Name} */\n";
				commandsPFN += $"#endif /* {feature.Name} */\n";
			}
			strings.Add("GL_ENUMS_COMMANDS", commandsAndEnums);
			strings.Add("GL_COMMANDS_PFN", commandsPFN);

			Directory.CreateDirectory("include/" + api.ToUpper());
			Directory.CreateDirectory("src");
			Output("../../../source.h.in", $"include/{strings["HEADER_FILE"]}", strings);
			Output("../../../source.cpp.in", $"src/{strings["SOURCE_FILE"]}", strings);
		}

		private static void Output(string inPath, string outPath, IReadOnlyDictionary<string, string> strings) {
			using var input = new StreamReader(inPath);
			using var output = new StreamWriter(outPath);

			string line;
			while ((line = input.ReadLine()) != null) {
				output.WriteLine(Regex.Replace(line, @"\$\{(.*?)\}",
					match => strings.TryGetValue(match.Groups[1].Value, out string value) ? value : match.Value
					));
			}
		}

		private static string GlType(RegistryCommands.Command.Proto proto) {
			var type = string.Join("", proto.Text).Trim();
			if (!string.IsNullOrEmpty(proto.PointerType))
				type = type.Insert(0, proto.PointerType.Trim() + (type.Length == 0 ? "" : " "));
			return type;
		}

		private static string GlType(RegistryCommands.Command.Param param) {
			var type = string.Join("", param.Text).Trim();
			if (!string.IsNullOrEmpty(param.PointerType))
				type = type.Insert(0, param.PointerType.Trim() + (type.Length == 0 ? "" : " "));
			return type;
		}

		private static void Download() {
			using var client = new WebClient();

			Directory.CreateDirectory("xml");
			if (!File.Exists("xml/egl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/EGL-Registry/master/api/egl.xml", "xml/egl.xml");
			if (!File.Exists("xml/gl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/gl.xml", "xml/gl.xml");
			if (!File.Exists("xml/glx.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/glx.xml", "xml/glx.xml");
			if (!File.Exists("xml/wgl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/wgl.xml", "xml/wgl.xml");

			Directory.CreateDirectory("include/KHR");
			if (!File.Exists("include/KHR/khrplatform.h"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/EGL-Registry/master/api/KHR/khrplatform.h", "include/KHR/khrplatform.h");
		}
	}

}
