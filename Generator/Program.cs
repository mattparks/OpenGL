using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Xml.Serialization;

namespace Generator {
	internal class Program {
		private static void Main(string[] args) {
			Download();

			Registry registry;
			using (var file = new FileStream("xml/gl.xml", FileMode.Open)) {
				var serializer = new XmlSerializer(typeof(Registry));
				registry = (Registry)serializer.Deserialize(file);
			}

			Process(registry, "gl", 1.0, 3.0); // 4.6
			//Process(registry, "gles1", 1.0);
		}

		private static void Process(Registry registry, string api, double min, double max) {
			var strings = new Dictionary<string, string> {
				{ "SHORTNAME", "gl" },
				{ "GENERATOR", $"// OpenGL loader generated by Matthew A's tool at {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ss.fffffffZ}" },
				{ "LICENSE", $"/*\n{registry.Comment}\n*/" },
				{ "TYPES", "" },
				{ "HEADER_BODY", "" },
				{ "SOURCE_PFN", "" },
				{ "LOADPROCS", "" }
			};

			foreach (var type in registry.Types.SelectMany(types => types.Types)) {
				if (type.Text.Count == 1) {
					// Struct declarations.
					strings["TYPES"] += $"{type.Name}{type.Text[0]}\n";
				} else if (type.Text.Count == 2) {
					// Typedef types.
					strings["TYPES"] += $"{type.Text[0]}{type.Name}{type.Text[1]}\n";
				} else if (type.Text.Count == 3) {
					// Typedef functions.
					strings["TYPES"] += $"{type.Text[0]}{(type.ApiEntry != null ? "GL_APIENTRY" : "")}{type.Text[1]}{type.Name}{type.Text[2]}\n";
				} else {
					throw new ArgumentException();
				}
			}

			foreach (var feature in registry.Features.Where(f => f.Api == api && f.Number >= min && f.Number <= max)) {
				//string section = $"#ifndef {feature.Name}\n#define {feature.Name} 1";
				string headerDefs = $"#ifndef {feature.Name}\n#define {feature.Name} 1\n/* SECTION: GL enumerant (token) definitions. */\n";
				string sourcePFN = $"#ifdef {feature.Name}\n";
				string loadProcs = $"#ifdef {feature.Name}\n";
				foreach (var enumName in feature.Requires.SelectMany(requires => requires.EnumNames)) {
					var @enum = registry.Find(enumName);
					headerDefs += $"#define {@enum.Name} {@enum.Value}\n";
				}

				headerDefs += "\n/* SECTION: GL command definitions. */\n";
				foreach (var commandName in feature.Requires.SelectMany(requires => requires.CommandNames)) {
					var command = registry.Find(commandName);
					var procName = $"PFN{command.Prototype.Name.ToUpper()}PROC";
					var implName = $"impl_{command.Prototype.Name}";
					var paramsString = string.Join(", ", command.Params.Select(param =>
						$"{GlType(param)} {param.Name}")
					);
					headerDefs += $"typedef {GlType(command.Prototype)}(GL_APIENTRYP {procName})({paramsString});\n";
					headerDefs += $"GL_APICALL {procName} impl_{command.Prototype.Name};\n";
					headerDefs += $"#define {command.Prototype.Name} {implName}\n";

					sourcePFN += $"{procName} {implName} = NULL;\n";
					loadProcs += $"\t{implName} = ({procName})proc(\"{command.Prototype.Name}\");\n";
				}

				headerDefs += $"#endif /* {feature.Name} */\n";
				sourcePFN += $"#endif /* {feature.Name} */\n";
				loadProcs += $"#endif /* {feature.Name} */\n";
				strings["HEADER_BODY"] += headerDefs;
				strings["SOURCE_PFN"] += sourcePFN;
				strings["LOADPROCS"] += loadProcs;
			}

			Directory.CreateDirectory("include/GL");
			Directory.CreateDirectory("src");
			Output("../../../header.template", "include/GL/OpenGL.h", strings);
			Output("../../../source.template", "src/OpenGL.cpp", strings);
		}

		private static void Output(string inPath, string outPath, IReadOnlyDictionary<string, string> strings) {
			using var input = new StreamReader(inPath);
			using var output = new StreamWriter(outPath);
			
			string line;
			while ((line = input.ReadLine()) != null) {
				var splitLine = line.Split("%%");
				if (line.Split("%%").Length - 1 == 2) {
					// Write what came before the first token
					output.Write(splitLine[0]);
					// Write the replacement to the tokens and the key.
					if (strings.ContainsKey(splitLine[1])) {
						output.Write(strings[splitLine[1]]);
					} else {
						// If we don't have a replacement we write the key back into the file.
						output.Write(splitLine[1]);
						Console.WriteLine($"Invalid generator key: {splitLine[1]}");
					}
					// Write what came after the token.
					output.WriteLine(splitLine[2]);
				} else {
					output.WriteLine(line);
				}
			}
		}

		private static string GlType(RegistryCommands.Command.Proto proto) {
			return !string.IsNullOrEmpty(proto.PointerType) ? proto.PointerType : proto.Text[0];
		}

		private static string GlType(RegistryCommands.Command.Param param) {
			return !string.IsNullOrEmpty(param.PointerType) ? param.PointerType : param.Text[0];
		}

		private static void Download() {
			using var client = new WebClient();

			Directory.CreateDirectory("xml");
			if (!File.Exists("xml/egl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/EGL-Registry/master/api/egl.xml", "xml/egl.xml");
			if (!File.Exists("xml/gl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/gl.xml", "xml/gl.xml");
			if (!File.Exists("xml/glx.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/glx.xml", "xml/glx.xml");
			if (!File.Exists("xml/wgl.xml"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/OpenGL-Registry/master/xml/wgl.xml", "xml/wgl.xml");
				
			Directory.CreateDirectory("include/KHR");
			if (!File.Exists("include/KHR/khrplatform.h"))
				client.DownloadFile("https://raw.githubusercontent.com/KhronosGroup/EGL-Registry/master/api/KHR/khrplatform.h", "include/KHR/khrplatform.h");
		}
	}

}
