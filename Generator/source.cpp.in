/*

${GENERATOR}

------------------------------------------------------------------------
${LICENSE}
*/

#include <${HEADER_FILE}>

#ifdef _WIN32
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#include <Windows.h>
#include <cassert>
#include <tchar.h>
#endif

namespace impl {
#ifdef _WIN32
#pragma comment(lib, "opengl32.lib")

gl::ProcAddress getProcAddress(const char *name) {
	static auto module = LoadLibrary(_T("OPENGL32.DLL"));

	// Prevent static linking of opengl32
	static auto wglGetProcAddress_ = reinterpret_cast<void *(WINAPI *)(const char *)>((uintptr_t) ::GetProcAddress(module, "wglGetProcAddress"));
	assert(wglGetProcAddress_ != nullptr);

	auto procAddress = wglGetProcAddress_(name);
	if (procAddress != nullptr) {
		return reinterpret_cast<gl::ProcAddress>(procAddress);
	}

	procAddress = (void *) ::GetProcAddress(module, name);
	return reinterpret_cast<gl::ProcAddress>(procAddress);
}
#else
gl::ProcAddress getProcAddress(const char *name) {
#ifdef SYSTEM_DARWIN
	static auto library = dlopen("/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL", RTLD_LAZY);
#else
	static auto library = dlopen("libGL.so", RTLD_LAZY);
#endif

	assert(library != nullptr);

	auto symbol = dlsym(library, name);
	return reinterpret_cast<gl::ProcAddress>(symbol);
}
#endif
}

namespace ${NAMESPACE} {
GetProcAddress getProcAddress = nullptr;

void initialize(const GetProcAddress &resolver) {
	if (resolver == nullptr)
		getProcAddress = impl::getProcAddress;
	else
		getProcAddress = resolver;
}

${GL_COMMANDS_PFN}
}
